{"version":3,"sources":["webpack:///webpack/bootstrap a0d0963c5e892c7045b0","webpack:///./src/anim-sequence.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;;AAGD;AACA;AACA,YAAY;AACZ,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,cAAc;AACd;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,eAAe,8CAA8C,GAAG;AAChE,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;;AAEA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA,yBAAyB;AACzB,mBAAmB;;AAEnB,YAAY;;AAEZ;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,kBAAkB;AAC/B,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC,8CAA8C;AAC9C;AACA,OAAO;AACP,2BAA2B;AAC3B;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,6E","file":"anim-sequence.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a0d0963c5e892c7045b0","/*\n * AnimSequence\n * https://anseki.github.io/anim-sequence/\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\n// *** Currently, this code except `export` is not ES2015. ***\n\nvar FUNC_KEYS = {\n  'ease': [0.25, 0.1, 0.25, 1],\n  'linear': [0, 0, 1, 1],\n  'ease-in': [0.42, 0, 1, 1],\n  'ease-out': [0, 0, 0.58, 1],\n  'ease-in-out': [0.42, 0, 0.58, 1]\n},\n    MSPF = 1000 / 60 / 2,\n    // precision ms/frame (FPS: 60)\n\nrequestAnim = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  setTimeout(callback, MSPF);\n},\n    cancelAnim = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (requestID) {\n  clearTimeout(requestID);\n},\n    isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && window.isFinite(value);\n},\n\n\n/**\n * @callback frameCallback\n * @param {} value - A value that was made by `valueCallback`.\n * @param {boolean} finish\n * @param {number} timeRatio - Progress [0, 1].\n * @param {number} outputRatio - Progress [0, 1].\n * @returns {} `false` to stop.\n */\n\n/**\n * @typedef {Object} task\n * @property {number} animId\n * @property {frameCallback} frameCallback - Callback that is called each frame.\n * @property {number} duration\n * @property {number} count - `0` as infinite.\n * @property {{value, timeRatio: number, outputRatio: number}[]} frames\n * @property {(number|null)} framesStart - The time when first frame ran, or `null` if it is not playing.\n * @property {number} loopsLeft - A counter for loop.\n * @property {number} lastFrame - index of last frame that ran.\n * @property {boolean} reverse - Play backwards.\n */\n\n/** @type {task[]} */\ntasks = [],\n    newAnimId = 0,\n    requestID;\n\nwindow.animTasks = tasks; // [DEBUG/]\nwindow.MSPF = MSPF; // [DEBUG/]\n\nvar playing; // [DEBUG/]\n\nfunction step() {\n  playing = true; // [DEBUG/]\n  var now = Date.now(),\n      next = false;\n  if (requestID) {\n    cancelAnim.call(window, requestID);\n    requestID = null;\n  }\n\n  tasks.forEach(function (task) {\n    var timeLen, loops, frame;\n\n    if (!task.framesStart) {\n      return;\n    }\n    timeLen = now - task.framesStart;\n\n    if (timeLen >= task.duration && task.count && task.loopsLeft <= 1) {\n      frame = task.frames[task.lastFrame = task.reverse ? 0 : task.frames.length - 1];\n      task.frameCallback(frame.value, true, frame.timeRatio, frame.outputRatio);\n      task.framesStart = null;\n      return;\n    }\n    if (timeLen > task.duration) {\n      loops = Math.floor(timeLen / task.duration);\n      if (task.count) {\n        if (loops >= task.loopsLeft) {\n          // Here `task.loopsLeft > 1`\n          frame = task.frames[task.lastFrame = task.reverse ? 0 : task.frames.length - 1];\n          task.frameCallback(frame.value, true, frame.timeRatio, frame.outputRatio);\n          task.framesStart = null;\n          return;\n        }\n        task.loopsLeft -= loops;\n      }\n      task.framesStart += task.duration * loops;\n      timeLen = now - task.framesStart;\n    }\n\n    if (task.reverse) {\n      timeLen = task.duration - timeLen;\n    }\n    frame = task.frames[task.lastFrame = Math.round(timeLen / MSPF)];\n    if (task.frameCallback(frame.value, false, frame.timeRatio, frame.outputRatio\n    /* [DEBUG] */, timeLen /* [/DEBUG] */) !== false) {\n      next = true;\n    } else {\n      task.framesStart = null;\n    }\n  });\n\n  if (next) {\n    requestID = requestAnim.call(window, step);\n  }\n}\n\n// [DEBUG]\nwindow.anim_lastPlaying = false;\nwindow.anim_watchStart = function () {\n  window.anim_watchTimer = setInterval(function () {\n    if (playing !== window.anim_lastPlaying) {\n      document.body.style.backgroundColor = playing ? '#f7f6cb' : '#fff'; // not `''` for TRIDENT bug\n      window.anim_lastPlaying = playing;\n    }\n    playing = false;\n  }, 200);\n};\nwindow.anim_watchStop = function () {\n  clearInterval(window.anim_watchTimer);\n};\n// [/DEBUG]\n\nfunction startTask(task, timeRatio) {\n  task.framesStart = Date.now();\n  if (timeRatio != null) {\n    task.framesStart -= task.duration * (task.reverse ? 1 - timeRatio : timeRatio);\n  }\n  task.loopsLeft = task.count;\n  task.lastFrame = null;\n  step();\n}\n\nvar AnimSequence = {\n  /**\n   * Callback that makes value that is required by each frame.\n   * @callback valueCallback\n   * @param {number} outputRatio - Progress [0, 1].\n   * @returns {}\n   */\n\n  /**\n   * @param {(valueCallback|null)} valueCallback - valueCallback\n   * @param {frameCallback} frameCallback - task property\n   * @param {number} duration - task property\n   * @param {number} count - task property\n   * @param {(string|number[])} timing - FUNC_KEYS or [x1, y1, x2, y2]\n   * @param {(boolean|null)} reverse - playing property\n   * @param {number|boolean} [timeRatio] - Play from the midst. [0, 1], or `false` that prevents it starting.\n   * @returns {number} animId to control the task.\n   */\n  add: function add(valueCallback, frameCallback, duration, count, timing, reverse, timeRatio) {\n    var animId = ++newAnimId,\n        task,\n        frames,\n        stepX,\n        stepT,\n        nextX,\n        t,\n        point;\n\n    function getPoint(t) {\n      var t2 = t * t,\n          t3 = t2 * t,\n          t1 = 1 - t,\n          t12 = t1 * t1,\n          p1f = 3 * t12 * t,\n          p2f = 3 * t1 * t2;\n      return {\n        x: p1f * timing[0] + p2f * timing[2] + t3,\n        y: p1f * timing[1] + p2f * timing[3] + t3\n      };\n    }\n\n    function newFrame(timeRatio, outputRatio) {\n      return { value: valueCallback(outputRatio),\n        timeRatio: timeRatio, outputRatio: outputRatio };\n    }\n\n    if (typeof timing === 'string') {\n      timing = FUNC_KEYS[timing];\n    }\n    valueCallback = valueCallback || function () {};\n\n    // Generate `frames` list\n    if (duration < MSPF) {\n      frames = [newFrame(0, 0), newFrame(1, 1)];\n    } else {\n      stepX = MSPF / duration;\n      frames = [newFrame(0, 0)];\n\n      if (timing[0] === 0 && timing[1] === 0 && timing[2] === 1 && timing[3] === 1) {\n        // linear\n        for (nextX = stepX; nextX <= 1; nextX += stepX) {\n          frames.push(newFrame(nextX, nextX)); // x === y\n        }\n      } else {\n        stepT = stepX / 10; // precision for `t`\n        nextX = stepX;\n        for (t = stepT; t <= 1; t += stepT) {\n          point = getPoint(t);\n          if (point.x >= nextX) {\n            frames.push(newFrame(point.x, point.y));\n            nextX += stepX;\n          }\n        }\n      }\n\n      frames.push(newFrame(1, 1)); // for tolerance\n    }\n\n    task = {\n      animId: animId,\n      frameCallback: frameCallback, duration: duration, count: count, // task properties\n      frames: frames,\n      reverse: !!reverse\n    };\n    tasks.push(task);\n    if (timeRatio !== false) {\n      startTask(task, timeRatio);\n    }\n\n    return animId;\n  },\n\n  remove: function remove(animId) {\n    var iRemove;\n    if (tasks.some(function (task, i) {\n      if (task.animId === animId) {\n        iRemove = i;\n        task.framesStart = null; // for `tasks.forEach` that is playing now.\n        return true;\n      }\n      return false;\n    })) {\n      tasks.splice(iRemove, 1);\n    }\n  },\n\n  /**\n   * @param {number} animId - Target task.\n   * @param {boolean} reverse - Play backwards.\n   * @param {number} [timeRatio] - Play from the midst. [0, 1]\n   * @returns {void}\n   */\n  start: function start(animId, reverse, timeRatio) {\n    tasks.some(function (task) {\n      if (task.animId === animId) {\n        task.reverse = !!reverse;\n        startTask(task, timeRatio);\n        return true;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * @param {number} animId - Target task.\n   * @param {boolean} [getTimeRatioByFrame] - Return timeRatio of last frame that ran. [0, 1]\n   * @returns {(number|undefined)} timeRatio [0, 1]\n   */\n  stop: function stop(animId, getTimeRatioByFrame) {\n    var timeRatio;\n    tasks.some(function (task) {\n      if (task.animId === animId) {\n        if (!getTimeRatioByFrame) {\n          timeRatio = (Date.now() - task.framesStart) / task.duration;\n          if (task.reverse) {\n            timeRatio = 1 - timeRatio;\n          }\n          if (timeRatio < 0) {\n            timeRatio = 0;\n          } else if (timeRatio > 1) {\n            timeRatio = 1;\n          }\n        } else if (task.lastFrame != null) {\n          timeRatio = task.frames[task.lastFrame].timeRatio;\n        }\n        task.framesStart = null;\n        return true;\n      }\n      return false;\n    });\n    return timeRatio;\n  },\n\n  validTiming: function validTiming(timing) {\n    return typeof timing === 'string' ? FUNC_KEYS[timing] : Array.isArray(timing) && [0, 1, 2, 3].every(function (i) {\n      return isFinite(timing[i]) && timing[i] >= 0 && timing[i] <= 1;\n    }) ? [timing[0], timing[1], timing[2], timing[3]] : null;\n  }\n};\n\nexport default AnimSequence;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/anim-sequence.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}