{"version":3,"sources":["webpack://AnimSequence/webpack/bootstrap","webpack://AnimSequence/./src/anim-sequence.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B,EAAE;;AAEtD;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB,EAAE;;AAEpD,iDAAiD,4DAA4D,EAAE;;AAE/G;AACA;AACA,cAAc;AACd,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,gBAAgB;AAChB;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,cAAc;AAC9B,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,iBAAiB,8CAA8C,GAAG;AAClE,gBAAgB,cAAc;AAC9B,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA,yBAAyB;AACzB,mBAAmB;;AAEnB,YAAY;;AAEZ;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH,aAAa,4CAA4C;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,GAAG;AACH;AACA,oCAAoC,uCAAuC;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,kBAAkB;AAC/B,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA,qCAAqC,4BAA4B;AACjE;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qFAAqF;AACrF,2BAA2B,YAAY;AACvC,8CAA8C;AAC9C;;AAEA,OAAO;AACP,2BAA2B;AAC3B;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;;AAE1D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA","file":"anim-sequence.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/anim-sequence.js\");\n","/*\n * AnimSequence\n * https://anseki.github.io/anim-sequence/\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\n// *** Currently, this code except `export` is not ES2015. ***\n\nvar\n  FUNC_KEYS = {\n    ease: [0.25, 0.1, 0.25, 1],\n    linear: [0, 0, 1, 1],\n    'ease-in': [0.42, 0, 1, 1],\n    'ease-out': [0, 0, 0.58, 1],\n    'ease-in-out': [0.42, 0, 0.58, 1]\n  },\n  MSPF = 1000 / 60 / 2, // precision ms/frame (FPS: 60)\n\n  requestAnim = window.requestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function(callback) { setTimeout(callback, MSPF); },\n\n  cancelAnim = window.cancelAnimationFrame ||\n    window.mozCancelAnimationFrame ||\n    window.webkitCancelAnimationFrame ||\n    window.msCancelAnimationFrame ||\n    function(requestID) { clearTimeout(requestID); },\n\n  isFinite = Number.isFinite || function(value) { return typeof value === 'number' && window.isFinite(value); },\n\n  /**\n   * @callback frameCallback\n   * @param {} value - A value that was made by `valueCallback`.\n   * @param {boolean} finish\n   * @param {number} timeRatio - Progress [0, 1].\n   * @param {number} outputRatio - Progress [0, 1].\n   * @returns {} `false` to stop.\n   */\n\n  /**\n   * @typedef {Object} task\n   * @property {number} animId\n   * @property {frameCallback} frameCallback - Callback that is called each frame.\n   * @property {number} duration\n   * @property {number} count - `0` as infinite.\n   * @property {{value, timeRatio: number, outputRatio: number}[]} frames\n   * @property {(number|null)} framesStart - The time when first frame ran, or `null` if it is not playing.\n   * @property {number} loopsLeft - A counter for loop.\n   * @property {number} lastFrame - index of last frame that ran.\n   * @property {boolean} reverse - Play backwards.\n   */\n\n  /** @type {task[]} */\n  tasks = [],\n  newAnimId = 0,\n  requestID;\n\nwindow.animTasks = tasks; // [DEBUG/]\nwindow.MSPF = MSPF; // [DEBUG/]\n\nvar playing; // [DEBUG/]\n\nfunction step() {\n  playing = true; // [DEBUG/]\n  var now = Date.now(),\n    next = false;\n  if (requestID) {\n    cancelAnim.call(window, requestID);\n    requestID = null;\n  }\n\n  tasks.forEach(function(task) {\n    var timeLen, loops, frame;\n\n    if (!task.framesStart) { return; }\n    timeLen = now - task.framesStart;\n\n    if (timeLen >= task.duration && task.count && task.loopsLeft <= 1) {\n      frame = task.frames[(task.lastFrame = task.reverse ? 0 : task.frames.length - 1)];\n      task.frameCallback(frame.value, true, frame.timeRatio, frame.outputRatio);\n      task.framesStart = null;\n      return;\n    }\n    if (timeLen > task.duration) {\n      loops = Math.floor(timeLen / task.duration);\n      if (task.count) {\n        if (loops >= task.loopsLeft) { // Here `task.loopsLeft > 1`\n          frame = task.frames[(task.lastFrame = task.reverse ? 0 : task.frames.length - 1)];\n          task.frameCallback(frame.value, true, frame.timeRatio, frame.outputRatio);\n          task.framesStart = null;\n          return;\n        }\n        task.loopsLeft -= loops;\n      }\n      task.framesStart += task.duration * loops;\n      timeLen = now - task.framesStart;\n    }\n\n    if (task.reverse) { timeLen = task.duration - timeLen; }\n    frame = task.frames[(task.lastFrame = Math.round(timeLen / MSPF))];\n    if (task.frameCallback(frame.value, false, frame.timeRatio, frame.outputRatio\n      /* [DEBUG] */, timeLen/* [/DEBUG] */) !== false) {\n      next = true;\n    } else {\n      task.framesStart = null;\n    }\n  });\n\n  if (next) { requestID = requestAnim.call(window, step); }\n}\n\n// [DEBUG]\nwindow.anim_lastPlaying = false;\nwindow.anim_watchStart = function() {\n  window.anim_watchTimer = setInterval(function() {\n    if (playing !== window.anim_lastPlaying) {\n      document.body.style.backgroundColor = playing ? '#f7f6cb' : '#fff'; // not `''` for TRIDENT bug\n      window.anim_lastPlaying = playing;\n    }\n    playing = false;\n  }, 200);\n};\nwindow.anim_watchStop = function() { clearInterval(window.anim_watchTimer); };\n// [/DEBUG]\n\nfunction startTask(task, timeRatio) {\n  task.framesStart = Date.now();\n  if (timeRatio != null) {\n    task.framesStart -= task.duration * (task.reverse ? 1 - timeRatio : timeRatio);\n  }\n  task.loopsLeft = task.count;\n  task.lastFrame = null;\n  step();\n}\n\nvar AnimSequence = {\n  /**\n   * Callback that makes value that is required by each frame.\n   * @callback valueCallback\n   * @param {number} outputRatio - Progress [0, 1].\n   * @returns {}\n   */\n\n  /**\n   * @param {(valueCallback|null)} valueCallback - valueCallback\n   * @param {frameCallback} frameCallback - task property\n   * @param {number} duration - task property\n   * @param {number} count - task property\n   * @param {(string|number[])} timing - FUNC_KEYS or [x1, y1, x2, y2]\n   * @param {(boolean|null)} reverse - playing property\n   * @param {number|boolean} [timeRatio] - Play from the midst. [0, 1], or `false` that prevents it starting.\n   * @returns {number} animId to control the task.\n   */\n  add: function(valueCallback, frameCallback, duration, count, timing, reverse, timeRatio) {\n    var animId = ++newAnimId,\n      task, frames, stepX, stepT, nextX, t, point;\n\n    function getPoint(t) {\n      var t2 = t * t,\n        t3 = t2 * t,\n        t1 = 1 - t,\n        t12 = t1 * t1,\n        p1f = 3 * t12 * t,\n        p2f = 3 * t1 * t2;\n      return {\n        x: p1f * timing[0] + p2f * timing[2] + t3,\n        y: p1f * timing[1] + p2f * timing[3] + t3\n      };\n    }\n\n    function newFrame(timeRatio, outputRatio) {\n      return {value: valueCallback(outputRatio),\n        timeRatio: timeRatio, outputRatio: outputRatio};\n    }\n\n    if (typeof timing === 'string') { timing = FUNC_KEYS[timing]; }\n    valueCallback = valueCallback || function() {};\n\n    // Generate `frames` list\n    if (duration < MSPF) {\n      frames = [newFrame(0, 0), newFrame(1, 1)];\n    } else {\n      stepX = MSPF / duration;\n      frames = [newFrame(0, 0)];\n\n      if (timing[0] === 0 && timing[1] === 0 && timing[2] === 1 && timing[3] === 1) { // linear\n        for (nextX = stepX; nextX <= 1; nextX += stepX) {\n          frames.push(newFrame(nextX, nextX)); // x === y\n        }\n\n      } else {\n        stepT = stepX / 10; // precision for `t`\n        nextX = stepX;\n        for (t = stepT; t <= 1; t += stepT) {\n          point = getPoint(t);\n          if (point.x >= nextX) {\n            frames.push(newFrame(point.x, point.y));\n            nextX += stepX;\n          }\n        }\n      }\n\n      frames.push(newFrame(1, 1)); // for tolerance\n    }\n\n    task = {\n      animId: animId,\n      frameCallback: frameCallback, duration: duration, count: count, // task properties\n      frames: frames,\n      reverse: !!reverse\n    };\n    tasks.push(task);\n    if (timeRatio !== false) { startTask(task, timeRatio); }\n\n    return animId;\n  },\n\n  remove: function(animId) {\n    var iRemove;\n    if (tasks.some(function(task, i) {\n      if (task.animId === animId) {\n        iRemove = i;\n        task.framesStart = null; // for `tasks.forEach` that is playing now.\n        return true;\n      }\n      return false;\n    })) {\n      tasks.splice(iRemove, 1);\n    }\n  },\n\n  /**\n   * @param {number} animId - Target task.\n   * @param {boolean} reverse - Play backwards.\n   * @param {number} [timeRatio] - Play from the midst. [0, 1]\n   * @returns {void}\n   */\n  start: function(animId, reverse, timeRatio) {\n    tasks.some(function(task) {\n      if (task.animId === animId) {\n        task.reverse = !!reverse;\n        startTask(task, timeRatio);\n        return true;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * @param {number} animId - Target task.\n   * @param {boolean} [getTimeRatioByFrame] - Return timeRatio of last frame that ran. [0, 1]\n   * @returns {(number|undefined)} timeRatio [0, 1]\n   */\n  stop: function(animId, getTimeRatioByFrame) {\n    var timeRatio;\n    tasks.some(function(task) {\n      if (task.animId === animId) {\n        if (!getTimeRatioByFrame) {\n          timeRatio = (Date.now() - task.framesStart) / task.duration;\n          if (task.reverse) { timeRatio = 1 - timeRatio; }\n          if (timeRatio < 0) {\n            timeRatio = 0;\n          } else if (timeRatio > 1) {\n            timeRatio = 1;\n          }\n        } else if (task.lastFrame != null) {\n          timeRatio = task.frames[task.lastFrame].timeRatio;\n        }\n        task.framesStart = null;\n        return true;\n      }\n      return false;\n    });\n    return timeRatio;\n  },\n\n  validTiming: function(timing) {\n    return typeof timing === 'string' ? FUNC_KEYS[timing] :\n      Array.isArray(timing) && [0, 1, 2, 3].every(function(i) {\n        return isFinite(timing[i]) && timing[i] >= 0 && timing[i] <= 1;\n      }) ? [timing[0], timing[1], timing[2], timing[3]] :\n      null;\n  }\n};\n\nexport default AnimSequence;\n"],"sourceRoot":""}